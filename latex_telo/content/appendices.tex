\begin{appendix}
\addappheadtotoc
\section{Python Code Listing}
\label{app_a}


\begin{lstlisting}[language=Python, title=NGSolve Shape Optimization Code in Python, label=final_code]
  from ngsolve import *
  from netgen.geom2d import SplineGeometry
  from ngsolve.webgui import Draw
  import numpy as np
  import matplotlib.pyplot as plt

  geo = SplineGeometry()
  h_coarse = 1
  h_fine = 0.15
  geo.AddRectangle( (-3,-2), (3, 2), bcs = ("top", "out", "bot", "in"), leftdomain=1, rightdomain=0, maxh=h_coarse) 
  geo.AddCircle(c=(0, 0), r=0.6, leftdomain=2, rightdomain=1, bc="outer_cylinder", maxh=h_fine) 
  geo.AddCircle(c=(0, 0), r=0.5, leftdomain=0, rightdomain=2, bc="cyl", maxh=h_fine) 
  mesh = Mesh(geo.GenerateMesh(maxh=h_coarse))
  mesh.Curve(2)

  # Order of spaces for Taylor-Hood Elements
  k = 2
  # H1 vs VectorH1 -> vector field?!
  V = H1(mesh,order=k, dirichlet="top|bot|cyl|in|out")
  Q = H1(mesh,order=k-1)
  FES = FESpace([V,V,Q]) # [V,Q] (without VectorH1)
  
  ux,uy,p = FES.TrialFunction()
  vx,vy,q = FES.TestFunction()

# stokes equation
def Equation(ux,uy,p,vx,vy,q):
    div_u = grad(ux)[0]+grad(uy)[1] # custom div
    div_v = grad(vx)[0]+grad(vy)[1]
    return (grad(ux)*grad(vx)+grad(uy)*grad(vy) + div_u*q + div_v*p)* dx

  a = BilinearForm(FES)
  a += Equation(ux,uy,p,vx,vy,q)
  a.Assemble()

  gfu = GridFunction(FES)
  uinf = 0.0005
  uin = CoefficientFunction((uinf))
  gfu.components[0].Set(uin, definedon=mesh.Boundaries("in|top|bot|out"))
  x_velocity = CoefficientFunction(gfu.components[0])
  scene_state = Draw(x_velocity, mesh, "vel")

  def solveStokes():
    res = gfu.vec.CreateVector()
    res.data = -a.mat * gfu.vec
    inv = a.mat.Inverse(FES.FreeDofs())
    gfu.vec.data += inv * res
    scene_state.Redraw()
  solveStokes()

  def calc_drag(gfu):
    ux = gfu.components[0]
    uy = gfu.components[1]
    return 0.5*(grad(ux)*grad(ux)+grad(uy)*grad(uy)).Compile()*dx

  alpha = 1e-4
  surf_t = CoefficientFunction(1)
  surf_0 = Integrate(surf_t,mesh)
    
  def calc_surf_change():
    return alpha*(surf_t*dx-surf_0)**2

  bc_tx = CoefficientFunction(x)
  bc_ty = CoefficientFunction(y)
  bc_0x = 1/surf_0*Integrate(bc_tx,mesh)
  bc_0y = 1/surf_0*Integrate(bc_ty,mesh)

  # Test and trial functions for shape derivate
  VEC = H1(mesh, order=2, dim=2, dirichlet="top|bot|in|out")
  PHI, X = VEC.TnT()
  # gfset denotes the deformation of the original domain and will be updated during the shape optimization
  gfset = GridFunction(VEC)
  gfset.Set((0,0))
  mesh.SetDeformation(gfset)
  SetVisualization (deformation=True)

  ux = gfu.components[0]
  uy = gfu.components[1]
  p = gfu.components[2]

  vol = Parameter(1)
  vol.Set(Integrate(surf_t,mesh))
  Lagrangian = Equation(ux,uy,p,ux,uy,p) + calc_drag(gfu) 

  dJOmega = LinearForm(VEC)
  # automatic shape differentiation
  dJOmega += Lagrangian.DiffShape(X)

  # volume side constraint
  vol = Parameter(1)
  vol.Set(Integrate(surf_t,mesh))
  alpha0 = 1e-4
  alpha = Parameter(alpha0)
  dJOmega += 2*alpha*(vol-surf_0)*div(X)*dx

  # barycenter x sideconstraint
  beta0 = 1e-3
  beta = Parameter(beta0)
  bc_x = Parameter(1)
  bc_x.Set((1/surf_0)*Integrate(bc_tx,mesh))
  dJOmega += 2*beta*(bc_x-bc_0x)*((1/vol**2)*div(X)*x+(1/vol)*div(X)*x*sum(gfset.vecs[0].data)[0])*dx

  # barycenter y sideconstraint
  bc_y = Parameter(1)
  bc_y.Set((1/surf_0)*Integrate(bc_ty,mesh))
  dJOmega += 2*beta*(bc_y-bc_0y)*((1/vol**2)*div(X)*y+(1/vol)*div(X)*y*sum(gfset.vecs[0].data)[1])*dx


  b = BilinearForm(VEC)
  #b += (InnerProduct(grad(X),grad(PHI))).Compile() *dx + (InnerProduct(X,PHI)).Compile()*dx
  b += (InnerProduct(grad(X),grad(PHI)+grad(PHI).trans)).Compile() *dx + (InnerProduct(X,PHI)).Compile()*dx

  #Cauchy-Riemann Penalisation
  gamma0 = 25
  gamma = Parameter(gamma0)
  Gamma = 150
  b += Gamma*(PHI.Deriv()[0,0] - PHI.Deriv()[1,1])*(X.Deriv()[0,0] - X.Deriv()[1,1])*dx
  b += Gamma*(PHI.Deriv()[1,0] - PHI.Deriv()[0,1])*(X.Deriv()[1,0] - X.Deriv()[0,1])*dx

  # deformation calculation
  gfX = GridFunction(VEC)

  def updateParams(v=False):
    vol.Set(Integrate(surf_t,mesh))
    bc_x.Set((1/surf_0)*Integrate(bc_tx,mesh))
    bc_y.Set((1/surf_0)*Integrate(bc_ty,mesh))
    if(v):
        print(vol.Get(), bc_x.Get(), bc_y.Get())
updateParams()

def increaseParams(k=2,v=False):
    alpha.Set(alpha.Get()*k)
    beta.Set(beta.Get()*k)
    gamma.Set(gamma.Get()*k)
    if(v):
        print("alpha: ", alpha.Get(), ", beta: ", beta.Get(), ", gamma: ", gamma.Get())

def SolveDeformationEquation():
    rhs = gfX.vec.CreateVector()
    rhs.data = dJOmega.vec - b.mat * gfX.vec
    update = gfX.vec.CreateVector()
    update.data = b.mat.Inverse(VEC.FreeDofs()) * rhs
    gfX.vec.data += update

gfset.Set((0,0))
mesh.SetDeformation(gfset)
scene.Redraw()

updateParams()
alpha0 = 1e-4
beta0 = 1e-0
gamma0 = 1e2
alpha.Set(alpha0)
beta.Set(beta0)
gamma.Set(gamma0)

a.Assemble()
solveStokes()

data = [[] for x in range(7)]

iter_max = 800
Jold = Integrate(calc_drag(gfu), mesh)

# try parts of loop
mesh.SetDeformation(gfset)
scene.Redraw()

c = 0

# input("Press enter to start optimization")
for i in range(0,iter_max):
    mesh.SetDeformation(gfset)
    scene.Redraw()
    scene_state.Redraw()
    
    if i%50 == 0:
        print('drag at iteration', i, ': ', Jold)
        
    titles = ["Energy Dissipation","Volume","bc_x","bc_y","scale","gfxnorm","gfxbndnorm"] # collecting data
    data[0].append(Integrate(calc_drag(gfu),mesh))
    data[1].append(vol.Get())
    data[2].append(bc_x.Get())
    data[3].append(bc_y.Get())
    
    a.Assemble()
    solveStokes()
    
    b.Assemble()
    dJOmega.Assemble()
    SolveDeformationEquation()
    updateParams()
    
    Jnew = Integrate(calc_drag(gfu), mesh)
    mesh.UnsetDeformation()
    
    gfxnorm = Norm(gfX.vec)
    gfxbndnorm = Integrate(sqrt(gfX**2),mesh,BND)
    data[6].append(gfxbndnorm)
    #scale = 0.1 / Norm(gfX.vec)
    scale = 0.01 / gfxnorm
    data[4].append(scale)
    jdiff = abs(Jnew-Jold)
    data[5].append(gfxnorm)
    
    
    c += 1
    #if(gfxnorm < 1e-5):
    if(gfxbndnorm < 1e-7 and c > 50):
        if alpha.Get() < 100:
            increaseParams(5,True)
            c = 0
        else:
            print("alpha too big")
            break
            
    gfsetOld = gfset
    gfset.vec.data -= scale * gfX.vec
    Jold = Jnew

    Redraw(blocking=True)

Element_Iterator = mesh.Elements()
Element_Quality_Data = np.empty(Element_Iterator.stop)
deformation_vector = np.asarray(gfset.vec)

# Element Quality ratio eta with sidelengths a,b,c of element K
def eta_K(abc):
    A, B, C = abc[0,:], abc[1,:], abc[2,:]
    a, b, c = np.linalg.norm(A-C), np.linalg.norm(A-B), np.linalg.norm(B-C)
    s = 1/2*(a+b+c) #half the circumference of element
    A = np.sqrt(s*(s-a)*(s-b)*(s-c)) #Area calculation with Heron Theorem
    r = 2*A / (a+b+c) # radius of inscribed circle
    R = (a*b*c) / (4*A) # radius of circumscribed circle
    eta = R / (2*r) 
    return eta

for elmnt in mesh.Elements():
    el = NodeId(ELEMENT,elmnt.nr)
    meshel = mesh[el]
    abc = np.empty([3,2])
    counter = 0

    for vert in elmnt.vertices:
        ve = NodeId(VERTEX, vert.nr)
        meshvert = mesh[ve]
        abc[counter] = np.asarray(meshvert.point) + deformation_vector[vert.nr]
        counter += 1

    counter = 0
    Element_Quality_Data[elmnt.nr] = eta_K(abc)
\end{lstlisting}

\vfill

\end{appendix}
